/* automatically generated by rust-bindgen */
use vk::*;


pub const VMA_STATS_STRING_ENABLED: u32 = 1;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    #[link_name = "\u{1}__security_cookie"]
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocator_T {
    _unused: [u8; 0],
}
pub type VmaAllocator = *mut VmaAllocator_T;
/// Callback function called after successful vkAllocateMemory.
pub type PFN_vmaAllocateDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: VkDeviceMemory,
        size: VkDeviceSize,
    ),
>;
/// Callback function called before vkFreeMemory.
pub type PFN_vmaFreeDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: VkDeviceMemory,
        size: VkDeviceSize,
    ),
>;
/// \brief Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`.
///
/// Provided for informative purpose, e.g. to gather statistics about number of
/// allocations or total amount of memory allocated in Vulkan.
///
/// Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDeviceMemoryCallbacks {
    /// Optional, can be null.
    pub pfnAllocate: PFN_vmaAllocateDeviceMemoryFunction,
    /// Optional, can be null.
    pub pfnFree: PFN_vmaFreeDeviceMemoryFunction,
}
#[test]
fn bindgen_test_layout_VmaDeviceMemoryCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<VmaDeviceMemoryCallbacks>(),
        16usize,
        concat!("Size of: ", stringify!(VmaDeviceMemoryCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaDeviceMemoryCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaDeviceMemoryCallbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaDeviceMemoryCallbacks>())).pfnAllocate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDeviceMemoryCallbacks),
            "::",
            stringify!(pfnAllocate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaDeviceMemoryCallbacks>())).pfnFree as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDeviceMemoryCallbacks),
            "::",
            stringify!(pfnFree)
        )
    );
}
impl VmaAllocatorCreateFlagBits {
    /// \brief Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time or synchronized externally by you.
    ///
    /// Using this flag may increase performance because internal mutexes are not used.
    pub const VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT: VmaAllocatorCreateFlagBits =
        VmaAllocatorCreateFlagBits(1);
}
impl VmaAllocatorCreateFlagBits {
    /// \brief Enables usage of VK_KHR_dedicated_allocation extension.
    ///
    /// Using this extenion will automatically allocate dedicated blocks of memory for
    /// some buffers and images instead of suballocating place for them out of bigger
    /// memory blocks (as if you explicitly used #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
    /// flag) when it is recommended by the driver. It may improve performance on some
    /// GPUs.
    ///
    /// You may set this flag only if you found out that following device extensions are
    /// supported, you enabled them while creating Vulkan device passed as
    /// VmaAllocatorCreateInfo::device, and you want them to be used internally by this
    /// library:
    ///
    /// - VK_KHR_get_memory_requirements2
    /// - VK_KHR_dedicated_allocation
    ///
    /// When this flag is set, you can experience following warnings reported by Vulkan
    /// validation layer. You can ignore them.
    ///
    /// > vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.
    pub const VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT: VmaAllocatorCreateFlagBits =
        VmaAllocatorCreateFlagBits(2);
}
impl VmaAllocatorCreateFlagBits {
    /// \brief Enables usage of VK_KHR_dedicated_allocation extension.
    ///
    /// Using this extenion will automatically allocate dedicated blocks of memory for
    /// some buffers and images instead of suballocating place for them out of bigger
    /// memory blocks (as if you explicitly used #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
    /// flag) when it is recommended by the driver. It may improve performance on some
    /// GPUs.
    ///
    /// You may set this flag only if you found out that following device extensions are
    /// supported, you enabled them while creating Vulkan device passed as
    /// VmaAllocatorCreateInfo::device, and you want them to be used internally by this
    /// library:
    ///
    /// - VK_KHR_get_memory_requirements2
    /// - VK_KHR_dedicated_allocation
    ///
    /// When this flag is set, you can experience following warnings reported by Vulkan
    /// validation layer. You can ignore them.
    ///
    /// > vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.
    pub const VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM: VmaAllocatorCreateFlagBits =
        VmaAllocatorCreateFlagBits(2147483647);
}
impl ::std::ops::BitOr<VmaAllocatorCreateFlagBits> for VmaAllocatorCreateFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        VmaAllocatorCreateFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for VmaAllocatorCreateFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: VmaAllocatorCreateFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<VmaAllocatorCreateFlagBits> for VmaAllocatorCreateFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        VmaAllocatorCreateFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for VmaAllocatorCreateFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: VmaAllocatorCreateFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
/// Flags for created #VmaAllocator.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct VmaAllocatorCreateFlagBits(pub i32);
pub type VmaAllocatorCreateFlags = VkFlags;
/// \brief Pointers to some Vulkan functions - a subset used by the library.
///
/// Used in VmaAllocatorCreateInfo::pVulkanFunctions.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VmaVulkanFunctions {
    pub vkGetPhysicalDeviceProperties: PFN_vkGetPhysicalDeviceProperties,
    pub vkGetPhysicalDeviceMemoryProperties: PFN_vkGetPhysicalDeviceMemoryProperties,
    pub vkAllocateMemory: PFN_vkAllocateMemory,
    pub vkFreeMemory: PFN_vkFreeMemory,
    pub vkMapMemory: PFN_vkMapMemory,
    pub vkUnmapMemory: PFN_vkUnmapMemory,
    pub vkBindBufferMemory: PFN_vkBindBufferMemory,
    pub vkBindImageMemory: PFN_vkBindImageMemory,
    pub vkGetBufferMemoryRequirements: PFN_vkGetBufferMemoryRequirements,
    pub vkGetImageMemoryRequirements: PFN_vkGetImageMemoryRequirements,
    pub vkCreateBuffer: PFN_vkCreateBuffer,
    pub vkDestroyBuffer: PFN_vkDestroyBuffer,
    pub vkCreateImage: PFN_vkCreateImage,
    pub vkDestroyImage: PFN_vkDestroyImage,
    pub vkGetBufferMemoryRequirements2KHR: PFN_vkGetBufferMemoryRequirements2KHR,
    pub vkGetImageMemoryRequirements2KHR: PFN_vkGetImageMemoryRequirements2KHR,
}
pub type PFN_vkGetPhysicalDeviceProperties = ::std::option::Option<
    unsafe extern "system" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties = ::std::option::Option<
    unsafe extern "system" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties,
    ),
>;
pub type PFN_vkAllocateMemory = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        pAllocateInfo: *const VkMemoryAllocateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pMemory: *mut VkDeviceMemory,
    ) -> VkResult,
>;
pub type PFN_vkFreeMemory = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkMapMemory = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        offset: VkDeviceSize,
        size: VkDeviceSize,
        flags: VkMemoryMapFlags,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkUnmapMemory =
    ::std::option::Option<unsafe extern "system" fn(device: VkDevice, memory: VkDeviceMemory)>;
pub type PFN_vkBindBufferMemory = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        buffer: VkBuffer,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        image: VkImage,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkGetBufferMemoryRequirements = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkGetImageMemoryRequirements = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        image: VkImage,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkCreateBuffer = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        pCreateInfo: *const VkBufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pBuffer: *mut VkBuffer,
    ) -> VkResult,
>;
pub type PFN_vkDestroyBuffer = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateBufferView = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        pCreateInfo: *const VkBufferViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkBufferView,
    ) -> VkResult,
>;
pub type PFN_vkDestroyBufferView = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        bufferView: VkBufferView,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateImage = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        pCreateInfo: *const VkImageCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pImage: *mut VkImage,
    ) -> VkResult,
>;
pub type PFN_vkDestroyImage = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        image: VkImage,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateImageView = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        pCreateInfo: *const VkImageViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkImageView,
    ) -> VkResult,
>;
pub type PFN_vkDestroyImageView = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        imageView: VkImageView,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkBindBufferMemory2 = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory2 = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetImageMemoryRequirements2 = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2KHR,
        pMemoryRequirements: *mut VkMemoryRequirements2KHR,
    ),
>;
pub type PFN_vkGetBufferMemoryRequirements2 = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2KHR,
        pMemoryRequirements: *mut VkMemoryRequirements2KHR,
    ),
>;
pub type PFN_vkGetPhysicalDeviceProperties2 = ::std::option::Option<
    unsafe extern "system" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2KHR,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties2 = ::std::option::Option<
    unsafe extern "system" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2KHR,
    ),
>;
pub type PFN_vkGetPhysicalDeviceProperties2KHR = ::std::option::Option<
    unsafe extern "system" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2KHR,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties2KHR = ::std::option::Option<
    unsafe extern "system" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2KHR,
    ),
>;
pub type PFN_vkGetImageMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2KHR,
        pMemoryRequirements: *mut VkMemoryRequirements2KHR,
    ),
>;
pub type PFN_vkGetBufferMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2KHR,
        pMemoryRequirements: *mut VkMemoryRequirements2KHR,
    ),
>;
pub type PFN_vkBindBufferMemory2KHR = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory2KHR = ::std::option::Option<
    unsafe extern "system" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfoKHR,
    ) -> VkResult,
>;
#[test]
fn bindgen_test_layout_VmaVulkanFunctions() {
    assert_eq!(
        ::std::mem::size_of::<VmaVulkanFunctions>(),
        128usize,
        concat!("Size of: ", stringify!(VmaVulkanFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaVulkanFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaVulkanFunctions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkGetPhysicalDeviceProperties as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetPhysicalDeviceProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkGetPhysicalDeviceMemoryProperties
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetPhysicalDeviceMemoryProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkAllocateMemory as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkAllocateMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkFreeMemory as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkFreeMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkMapMemory as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkMapMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkUnmapMemory as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkUnmapMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkBindBufferMemory as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkBindBufferMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkBindImageMemory as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkBindImageMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkGetBufferMemoryRequirements as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetBufferMemoryRequirements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkGetImageMemoryRequirements as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetImageMemoryRequirements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkCreateBuffer as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkCreateBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkDestroyBuffer as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkDestroyBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkCreateImage as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkCreateImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkDestroyImage as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkDestroyImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkGetBufferMemoryRequirements2KHR
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetBufferMemoryRequirements2KHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaVulkanFunctions>())).vkGetImageMemoryRequirements2KHR
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetImageMemoryRequirements2KHR)
        )
    );
}
/// Description of a Allocator to be created.
#[repr(C)]
pub struct VmaAllocatorCreateInfo {
    /// Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.
    pub flags: VmaAllocatorCreateFlags,
    /// Vulkan physical device.
    /// /** It must be valid throughout whole lifetime of created allocator. */
    pub physicalDevice: VkPhysicalDevice,
    /// Vulkan device.
    /// /** It must be valid throughout whole lifetime of created allocator. */
    pub device: VkDevice,
    /// Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.
    /// /** Set to 0 to use default, which is currently 256 MiB. */
    pub preferredLargeHeapBlockSize: VkDeviceSize,
    /// Custom CPU memory allocation callbacks. Optional.
    /// /** Optional, can be null. When specified, will also be used for all CPU-side memory allocations. */
    pub pAllocationCallbacks: *const VkAllocationCallbacks,
    /// Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional.
    /// /** Optional, can be null. */
    pub pDeviceMemoryCallbacks: *const VmaDeviceMemoryCallbacks,
    /// \brief Maximum number of additional frames that are in use at the same time as current frame.
    ///
    /// This value is used only when you make allocations with
    /// VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocation cannot become
    /// lost if allocation.lastUseFrameIndex >= allocator.currentFrameIndex - frameInUseCount.
    ///
    /// For example, if you double-buffer your command buffers, so resources used for
    /// rendering in previous frame may still be in use by the GPU at the moment you
    /// allocate resources needed for the current frame, set this value to 1.
    ///
    /// If you want to allow any allocations other than used in the current frame to
    /// become lost, set this value to 0.
    pub frameInUseCount: u32,
    /// \brief Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap.
    ///
    /// If not NULL, it must be a pointer to an array of
    /// `VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on
    /// maximum number of bytes that can be allocated out of particular Vulkan memory
    /// heap.
    ///
    /// Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that
    /// heap. This is also the default in case of `pHeapSizeLimit` = NULL.
    ///
    /// If there is a limit defined for a heap:
    ///
    /// - If user tries to allocate more memory from that heap using this allocator,
    /// the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
    /// - If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the
    /// value of this limit will be reported instead when using vmaGetMemoryProperties().
    ///
    /// Warning! Using this feature may not be equivalent to installing a GPU with
    /// smaller amount of memory, because graphics driver doesn't necessary fail new
    /// allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is
    /// exceeded. It may return success and just silently migrate some device memory
    /// blocks to system RAM.
    pub pHeapSizeLimit: *const VkDeviceSize,
    /// \brief Pointers to Vulkan functions. Can be null if you leave define `VMA_STATIC_VULKAN_FUNCTIONS 1`.
    ///
    /// If you leave define `VMA_STATIC_VULKAN_FUNCTIONS 1` in configuration section,
    /// you can pass null as this member, because the library will fetch pointers to
    /// Vulkan functions internally in a static way, like:
    ///
    /// vulkanFunctions.vkAllocateMemory = &vkAllocateMemory;
    ///
    /// Fill this member if you want to provide your own pointers to Vulkan functions,
    /// e.g. fetched using `vkGetInstanceProcAddr()` and `vkGetDeviceProcAddr()`.
    pub pVulkanFunctions: *const VmaVulkanFunctions,
}
#[test]
fn bindgen_test_layout_VmaAllocatorCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VmaAllocatorCreateInfo>(),
        72usize,
        concat!("Size of: ", stringify!(VmaAllocatorCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaAllocatorCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaAllocatorCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocatorCreateInfo>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocatorCreateInfo>())).physicalDevice as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(physicalDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocatorCreateInfo>())).device as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocatorCreateInfo>())).preferredLargeHeapBlockSize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(preferredLargeHeapBlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocatorCreateInfo>())).pAllocationCallbacks as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(pAllocationCallbacks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocatorCreateInfo>())).pDeviceMemoryCallbacks as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(pDeviceMemoryCallbacks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocatorCreateInfo>())).frameInUseCount as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(frameInUseCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocatorCreateInfo>())).pHeapSizeLimit as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(pHeapSizeLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocatorCreateInfo>())).pVulkanFunctions as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(pVulkanFunctions)
        )
    );
}
extern "C" {
    /// Creates Allocator object.
    pub fn vmaCreateAllocator(
        pCreateInfo: *const VmaAllocatorCreateInfo,
        pAllocator: *mut VmaAllocator,
    ) -> VkResult;
}
extern "C" {
    /// Destroys allocator object.
    pub fn vmaDestroyAllocator(allocator: VmaAllocator);
}
extern "C" {
    /// PhysicalDeviceProperties are fetched from physicalDevice by the allocator.
    /// You can access it here, without fetching it again on your own.
    pub fn vmaGetPhysicalDeviceProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceProperties: *mut *const VkPhysicalDeviceProperties,
    );
}
extern "C" {
    /// PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.
    /// You can access it here, without fetching it again on your own.
    pub fn vmaGetMemoryProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceMemoryProperties: *mut *const VkPhysicalDeviceMemoryProperties,
    );
}
extern "C" {
    /// \brief Given Memory Type Index, returns Property Flags of this memory type.
    ///
    /// This is just a convenience function. Same information can be obtained using
    /// vmaGetMemoryProperties().
    pub fn vmaGetMemoryTypeProperties(
        allocator: VmaAllocator,
        memoryTypeIndex: u32,
        pFlags: *mut VkMemoryPropertyFlags,
    );
}
extern "C" {
    /// \brief Sets index of the current frame.
    ///
    /// This function must be used if you make allocations with
    /// #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT and
    /// #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flags to inform the allocator
    /// when a new frame begins. Allocations queried using vmaGetAllocationInfo() cannot
    /// become lost in the current frame.
    pub fn vmaSetCurrentFrameIndex(allocator: VmaAllocator, frameIndex: u32);
}
/// \brief Calculated statistics of memory usage in entire allocator.
#[repr(C)]
pub struct VmaStatInfo {
    /// Number of `VkDeviceMemory` Vulkan memory blocks allocated.
    pub blockCount: u32,
    /// Number of #VmaAllocation allocation objects allocated.
    pub allocationCount: u32,
    /// Number of free ranges of memory between allocations.
    pub unusedRangeCount: u32,
    /// Total number of bytes occupied by all allocations.
    pub usedBytes: VkDeviceSize,
    /// Total number of bytes occupied by unused ranges.
    pub unusedBytes: VkDeviceSize,
    pub allocationSizeMin: VkDeviceSize,
    pub allocationSizeAvg: VkDeviceSize,
    pub allocationSizeMax: VkDeviceSize,
    pub unusedRangeSizeMin: VkDeviceSize,
    pub unusedRangeSizeAvg: VkDeviceSize,
    pub unusedRangeSizeMax: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VmaStatInfo() {
    assert_eq!(
        ::std::mem::size_of::<VmaStatInfo>(),
        80usize,
        concat!("Size of: ", stringify!(VmaStatInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaStatInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaStatInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).blockCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(blockCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).allocationCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(allocationCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).unusedRangeCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(unusedRangeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).usedBytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(usedBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).unusedBytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(unusedBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).allocationSizeMin as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(allocationSizeMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).allocationSizeAvg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(allocationSizeAvg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).allocationSizeMax as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(allocationSizeMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).unusedRangeSizeMin as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(unusedRangeSizeMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).unusedRangeSizeAvg as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(unusedRangeSizeAvg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStatInfo>())).unusedRangeSizeMax as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatInfo),
            "::",
            stringify!(unusedRangeSizeMax)
        )
    );
}
/// General statistics from current state of Allocator.
#[repr(C)]
pub struct VmaStats {
    pub memoryType: [VmaStatInfo; 32usize],
    pub memoryHeap: [VmaStatInfo; 16usize],
    pub total: VmaStatInfo,
}
#[test]
fn bindgen_test_layout_VmaStats() {
    assert_eq!(
        ::std::mem::size_of::<VmaStats>(),
        3920usize,
        concat!("Size of: ", stringify!(VmaStats))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaStats>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaStats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStats>())).memoryType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStats),
            "::",
            stringify!(memoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStats>())).memoryHeap as *const _ as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStats),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaStats>())).total as *const _ as usize },
        3840usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStats),
            "::",
            stringify!(total)
        )
    );
}
extern "C" {
    /// Retrieves statistics from current state of the Allocator.
    pub fn vmaCalculateStats(allocator: VmaAllocator, pStats: *mut VmaStats);
}
extern "C" {
    /// Builds and returns statistics as string in JSON format.
    /// ** @param[out] ppStatsString Must be freed using vmaFreeStatsString() function.
    /// */
    pub fn vmaBuildStatsString(
        allocator: VmaAllocator,
        ppStatsString: *mut *mut ::std::os::raw::c_char,
        detailedMap: VkBool32,
    );
}
extern "C" {
    pub fn vmaFreeStatsString(allocator: VmaAllocator, pStatsString: *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaPool_T {
    _unused: [u8; 0],
}
pub type VmaPool = *mut VmaPool_T;
#[repr(i32)]
/// \struct VmaPool
/// \brief Represents custom memory pool
///
/// Fill structure VmaPoolCreateInfo and call function vmaCreatePool() to create it.
/// Call function vmaDestroyPool() to destroy it.
///
/// For more information see [Custom memory pools](@ref choosing_memory_type_custom_memory_pools).
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VmaMemoryUsage {
    /// No intended memory usage specified.
    /// Use other members of VmaAllocationCreateInfo to specify your requirements.
    VMA_MEMORY_USAGE_UNKNOWN = 0,
    /// Memory will be used on device only, so fast access from the device is preferred.
    /// It usually means device-local GPU (video) memory.
    /// No need to be mappable on host.
    /// It is roughly equivalent of `D3D12_HEAP_TYPE_DEFAULT`.
    ///
    /// Usage:
    ///
    /// - Resources written and read by device, e.g. images used as attachments.
    /// - Resources transferred from host once (immutable) or infrequently and read by
    /// device multiple times, e.g. textures to be sampled, vertex buffers, uniform
    /// (constant) buffers, and majority of other types of resources used by device.
    ///
    /// Allocation may still end up in `HOST_VISIBLE` memory on some implementations.
    /// In such case, you are free to map it.
    /// You can use #VMA_ALLOCATION_CREATE_MAPPED_BIT with this usage type.
    VMA_MEMORY_USAGE_GPU_ONLY = 1,
    /// Memory will be mappable on host.
    /// It usually means CPU (system) memory.
    /// Resources created in this pool may still be accessible to the device, but access to them can be slower.
    /// Guarantees to be `HOST_VISIBLE` and `HOST_COHERENT`.
    /// CPU read may be uncached.
    /// It is roughly equivalent of `D3D12_HEAP_TYPE_UPLOAD`.
    ///
    /// Usage: Staging copy of resources used as transfer source.
    VMA_MEMORY_USAGE_CPU_ONLY = 2,
    /// Memory that is both mappable on host (guarantees to be `HOST_VISIBLE`) and preferably fast to access by GPU.
    /// CPU reads may be uncached and very slow.
    ///
    /// Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every draw call.
    VMA_MEMORY_USAGE_CPU_TO_GPU = 3,
    /// Memory mappable on host (guarantees to be `HOST_VISIBLE`) and cached.
    /// It is roughly equivalent of `D3D12_HEAP_TYPE_READBACK`.
    ///
    /// Usage:
    ///
    /// - Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.
    /// - Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision detection.
    VMA_MEMORY_USAGE_GPU_TO_CPU = 4,
    /// Memory mappable on host (guarantees to be `HOST_VISIBLE`) and cached.
    /// It is roughly equivalent of `D3D12_HEAP_TYPE_READBACK`.
    ///
    /// Usage:
    ///
    /// - Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.
    /// - Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision detection.
    VMA_MEMORY_USAGE_MAX_ENUM = 2147483647,
}
impl VmaAllocationCreateFlagBits {
    /// \brief Set this flag if the allocation should have its own memory block.
    ///
    /// Use it for special, big resources, like fullscreen images used as attachments.
    ///
    /// This flag must also be used for host visible resources that you want to map
    /// simultaneously because otherwise they might end up as regions of the same
    /// `VkDeviceMemory`, while mapping same `VkDeviceMemory` multiple times
    /// simultaneously is illegal.
    ///
    /// You should not use this flag if VmaAllocationCreateInfo::pool is not null.
    pub const VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT: VmaAllocationCreateFlagBits =
        VmaAllocationCreateFlagBits(1);
}
impl VmaAllocationCreateFlagBits {
    /// \brief Set this flag to only try to allocate from existing `VkDeviceMemory` blocks and never create new such block.
    ///
    /// If new allocation cannot be placed in any of the existing blocks, allocation
    /// fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error.
    ///
    /// You should not use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT and
    /// #VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT at the same time. It makes no sense.
    ///
    /// If VmaAllocationCreateInfo::pool is not null, this flag is implied and ignored.
    pub const VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT: VmaAllocationCreateFlagBits =
        VmaAllocationCreateFlagBits(2);
}
impl VmaAllocationCreateFlagBits {
    /// \brief Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
    ///
    /// Pointer to mapped memory will be returned through VmaAllocationInfo::pMappedData.
    ///
    /// Is it valid to use this flag for allocation made from memory type that is not
    /// `HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is
    /// useful if you need an allocation that is efficient to use on GPU
    /// (`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that
    /// support it (e.g. Intel GPU).
    ///
    /// You should not use this flag together with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT.
    pub const VMA_ALLOCATION_CREATE_MAPPED_BIT: VmaAllocationCreateFlagBits =
        VmaAllocationCreateFlagBits(4);
}
impl VmaAllocationCreateFlagBits {
    /// Allocation created with this flag can become lost as a result of another
    /// allocation with #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flag, so you
    /// must check it before use.
    ///
    /// To check if allocation is not lost, call vmaGetAllocationInfo() and check if
    /// VmaAllocationInfo::deviceMemory is not `VK_NULL_HANDLE`.
    ///
    /// For details about supporting lost allocations, see Lost Allocations
    /// chapter of User Guide on Main Page.
    ///
    /// You should not use this flag together with #VMA_ALLOCATION_CREATE_MAPPED_BIT.
    pub const VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT: VmaAllocationCreateFlagBits =
        VmaAllocationCreateFlagBits(8);
}
impl VmaAllocationCreateFlagBits {
    /// While creating allocation using this flag, other allocations that were
    /// created with flag #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT can become lost.
    ///
    /// For details about supporting lost allocations, see Lost Allocations
    /// chapter of User Guide on Main Page.
    pub const VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT: VmaAllocationCreateFlagBits =
        VmaAllocationCreateFlagBits(16);
}
impl VmaAllocationCreateFlagBits {
    /// Set this flag to treat VmaAllocationCreateInfo::pUserData as pointer to a
    /// null-terminated string. Instead of copying pointer value, a local copy of the
    /// string is made and stored in allocation's `pUserData`. The string is automatically
    /// freed together with the allocation. It is also used in vmaBuildStatsString().
    pub const VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT: VmaAllocationCreateFlagBits =
        VmaAllocationCreateFlagBits(32);
}
impl VmaAllocationCreateFlagBits {
    /// Set this flag to treat VmaAllocationCreateInfo::pUserData as pointer to a
    /// null-terminated string. Instead of copying pointer value, a local copy of the
    /// string is made and stored in allocation's `pUserData`. The string is automatically
    /// freed together with the allocation. It is also used in vmaBuildStatsString().
    pub const VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM: VmaAllocationCreateFlagBits =
        VmaAllocationCreateFlagBits(2147483647);
}
impl ::std::ops::BitOr<VmaAllocationCreateFlagBits> for VmaAllocationCreateFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        VmaAllocationCreateFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for VmaAllocationCreateFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: VmaAllocationCreateFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<VmaAllocationCreateFlagBits> for VmaAllocationCreateFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        VmaAllocationCreateFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for VmaAllocationCreateFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: VmaAllocationCreateFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
/// Flags to be passed as VmaAllocationCreateInfo::flags.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct VmaAllocationCreateFlagBits(pub i32);
pub type VmaAllocationCreateFlags = VkFlags;
#[repr(C)]
pub struct VmaAllocationCreateInfo {
    /// Use #VmaAllocationCreateFlagBits enum.
    pub flags: VmaAllocationCreateFlags,
    /// \brief Intended usage of memory.
    ///
    /// You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. \n
    /// If `pool` is not null, this member is ignored.
    pub usage: VmaMemoryUsage,
    /// \brief Flags that must be set in a Memory Type chosen for an allocation.
    ///
    /// Leave 0 if you specify memory requirements in other way. \n
    /// If `pool` is not null, this member is ignored.
    pub requiredFlags: VkMemoryPropertyFlags,
    /// \brief Flags that preferably should be set in a memory type chosen for an allocation.
    ///
    /// Set to 0 if no additional flags are prefered. \n
    /// If `pool` is not null, this member is ignored.
    pub preferredFlags: VkMemoryPropertyFlags,
    /// \brief Bitmask containing one bit set for every memory type acceptable for this allocation.
    ///
    /// Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if
    /// it meets other requirements specified by this structure, with no further
    /// restrictions on memory type index. \n
    /// If `pool` is not null, this member is ignored.
    pub memoryTypeBits: u32,
    /// \brief Pool that this allocation should be created in.
    ///
    /// Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:
    /// `usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored.
    pub pool: VmaPool,
    /// \brief Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData().
    ///
    /// If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either
    /// null or pointer to a null-terminated string. The string will be then copied to
    /// internal buffer, so it doesn't need to be valid after allocation call.
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VmaAllocationCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VmaAllocationCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VmaAllocationCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaAllocationCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaAllocationCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocationCreateInfo>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocationCreateInfo>())).usage as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocationCreateInfo>())).requiredFlags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(requiredFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocationCreateInfo>())).preferredFlags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(preferredFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocationCreateInfo>())).memoryTypeBits as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(memoryTypeBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocationCreateInfo>())).pool as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaAllocationCreateInfo>())).pUserData as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(pUserData)
        )
    );
}
extern "C" {
    /// \brief Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo.
    ///
    /// This algorithm tries to find a memory type that:
    ///
    /// - Is allowed by memoryTypeBits.
    /// - Contains all the flags from pAllocationCreateInfo->requiredFlags.
    /// - Matches intended usage.
    /// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.
    ///
    /// \return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result
    /// from this function or any other allocating function probably means that your
    /// device doesn't support any memory type with requested features for the specific
    /// type of resource you want to use it for. Please check parameters of your
    /// resource, like image layout (OPTIMAL versus LINEAR) or mip level count.
    pub fn vmaFindMemoryTypeIndex(
        allocator: VmaAllocator,
        memoryTypeBits: u32,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    /// \brief Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.
    ///
    /// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
    /// It internally creates a temporary, dummy buffer that never has memory bound.
    /// It is just a convenience function, equivalent to calling:
    ///
    /// - `vkCreateBuffer`
    /// - `vkGetBufferMemoryRequirements`
    /// - `vmaFindMemoryTypeIndex`
    /// - `vkDestroyBuffer`
    pub fn vmaFindMemoryTypeIndexForBufferInfo(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    /// \brief Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.
    ///
    /// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
    /// It internally creates a temporary, dummy image that never has memory bound.
    /// It is just a convenience function, equivalent to calling:
    ///
    /// - `vkCreateImage`
    /// - `vkGetImageMemoryRequirements`
    /// - `vmaFindMemoryTypeIndex`
    /// - `vkDestroyImage`
    pub fn vmaFindMemoryTypeIndexForImageInfo(
        allocator: VmaAllocator,
        pImageCreateInfo: *const VkImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> VkResult;
}
impl VmaPoolCreateFlagBits {
    /// \brief Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored.
    ///
    /// This is na optional optimization flag.
    ///
    /// If you always allocate using vmaCreateBuffer(), vmaCreateImage(),
    /// vmaAllocateMemoryForBuffer(), then you don't need to use it because allocator
    /// knows exact type of your allocations so it can handle Buffer-Image Granularity
    /// in the optimal way.
    ///
    /// If you also allocate using vmaAllocateMemoryForImage() or vmaAllocateMemory(),
    /// exact type of such allocations is not known, so allocator must be conservative
    /// in handling Buffer-Image Granularity, which can lead to suboptimal allocation
    /// (wasted memory). In that case, if you can make sure you always allocate only
    /// buffers and linear images or only optimal images out of this pool, use this flag
    /// to make allocator disregard Buffer-Image Granularity and so make allocations
    /// more optimal.
    pub const VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT: VmaPoolCreateFlagBits =
        VmaPoolCreateFlagBits(2);
}
impl VmaPoolCreateFlagBits {
    /// \brief Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored.
    ///
    /// This is na optional optimization flag.
    ///
    /// If you always allocate using vmaCreateBuffer(), vmaCreateImage(),
    /// vmaAllocateMemoryForBuffer(), then you don't need to use it because allocator
    /// knows exact type of your allocations so it can handle Buffer-Image Granularity
    /// in the optimal way.
    ///
    /// If you also allocate using vmaAllocateMemoryForImage() or vmaAllocateMemory(),
    /// exact type of such allocations is not known, so allocator must be conservative
    /// in handling Buffer-Image Granularity, which can lead to suboptimal allocation
    /// (wasted memory). In that case, if you can make sure you always allocate only
    /// buffers and linear images or only optimal images out of this pool, use this flag
    /// to make allocator disregard Buffer-Image Granularity and so make allocations
    /// more optimal.
    pub const VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM: VmaPoolCreateFlagBits =
        VmaPoolCreateFlagBits(2147483647);
}
impl ::std::ops::BitOr<VmaPoolCreateFlagBits> for VmaPoolCreateFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        VmaPoolCreateFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for VmaPoolCreateFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: VmaPoolCreateFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<VmaPoolCreateFlagBits> for VmaPoolCreateFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        VmaPoolCreateFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for VmaPoolCreateFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: VmaPoolCreateFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
/// Flags to be passed as VmaPoolCreateInfo::flags.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct VmaPoolCreateFlagBits(pub i32);
pub type VmaPoolCreateFlags = VkFlags;
/// \brief Describes parameter of created #VmaPool.
#[repr(C)]
pub struct VmaPoolCreateInfo {
    /// \brief Vulkan memory type index to allocate this pool from.
    pub memoryTypeIndex: u32,
    /// \brief Use combination of #VmaPoolCreateFlagBits.
    pub flags: VmaPoolCreateFlags,
    /// \brief Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in bytes.
    ///
    /// Optional. Leave 0 to use default.
    pub blockSize: VkDeviceSize,
    /// \brief Minimum number of blocks to be always allocated in this pool, even if they stay empty.
    ///
    /// Set to 0 to have no preallocated blocks and let the pool be completely empty.
    pub minBlockCount: usize,
    /// \brief Maximum number of blocks that can be allocated in this pool. Optional.
    ///
    /// Optional. Set to 0 to use `SIZE_MAX`, which means no limit.
    ///
    /// Set to same value as minBlockCount to have fixed amount of memory allocated
    /// throuout whole lifetime of this pool.
    pub maxBlockCount: usize,
    /// \brief Maximum number of additional frames that are in use at the same time as current frame.
    ///
    /// This value is used only when you make allocations with
    /// #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocation cannot become
    /// lost if allocation.lastUseFrameIndex >= allocator.currentFrameIndex - frameInUseCount.
    ///
    /// For example, if you double-buffer your command buffers, so resources used for
    /// rendering in previous frame may still be in use by the GPU at the moment you
    /// allocate resources needed for the current frame, set this value to 1.
    ///
    /// If you want to allow any allocations other than used in the current frame to
    /// become lost, set this value to 0.
    pub frameInUseCount: u32,
}
#[test]
fn bindgen_test_layout_VmaPoolCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VmaPoolCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VmaPoolCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaPoolCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaPoolCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaPoolCreateInfo>())).memoryTypeIndex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(memoryTypeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaPoolCreateInfo>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaPoolCreateInfo>())).blockSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaPoolCreateInfo>())).minBlockCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(minBlockCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaPoolCreateInfo>())).maxBlockCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(maxBlockCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaPoolCreateInfo>())).frameInUseCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(frameInUseCount)
        )
    );
}
/// \brief Describes parameter of existing #VmaPool.
#[repr(C)]
pub struct VmaPoolStats {
    /// \brief Total amount of `VkDeviceMemory` allocated from Vulkan for this pool, in bytes.
    pub size: VkDeviceSize,
    /// \brief Total number of bytes in the pool not used by any #VmaAllocation.
    pub unusedSize: VkDeviceSize,
    /// \brief Number of #VmaAllocation objects created from this pool that were not destroyed or lost.
    pub allocationCount: usize,
    /// \brief Number of continuous memory ranges in the pool not used by any #VmaAllocation.
    pub unusedRangeCount: usize,
    /// \brief Size of the largest continuous free memory region.
    ///
    /// Making a new allocation of that size is not guaranteed to succeed because of
    /// possible additional margin required to respect alignment and buffer/image
    /// granularity.
    pub unusedRangeSizeMax: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VmaPoolStats() {
    assert_eq!(
        ::std::mem::size_of::<VmaPoolStats>(),
        40usize,
        concat!("Size of: ", stringify!(VmaPoolStats))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaPoolStats>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaPoolStats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaPoolStats>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolStats),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaPoolStats>())).unusedSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolStats),
            "::",
            stringify!(unusedSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaPoolStats>())).allocationCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolStats),
            "::",
            stringify!(allocationCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaPoolStats>())).unusedRangeCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolStats),
            "::",
            stringify!(unusedRangeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaPoolStats>())).unusedRangeSizeMax as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolStats),
            "::",
            stringify!(unusedRangeSizeMax)
        )
    );
}
extern "C" {
    /// \brief Allocates Vulkan device memory and creates #VmaPool object.
    ///
    /// @param allocator Allocator object.
    /// @param pCreateInfo Parameters of pool to create.
    /// @param[out] pPool Handle to created pool.
    pub fn vmaCreatePool(
        allocator: VmaAllocator,
        pCreateInfo: *const VmaPoolCreateInfo,
        pPool: *mut VmaPool,
    ) -> VkResult;
}
extern "C" {
    /// \brief Destroys #VmaPool object and frees Vulkan device memory.
    pub fn vmaDestroyPool(allocator: VmaAllocator, pool: VmaPool);
}
extern "C" {
    /// \brief Retrieves statistics of existing #VmaPool object.
    ///
    /// @param allocator Allocator object.
    /// @param pool Pool object.
    /// @param[out] pPoolStats Statistics of specified pool.
    pub fn vmaGetPoolStats(allocator: VmaAllocator, pool: VmaPool, pPoolStats: *mut VmaPoolStats);
}
extern "C" {
    /// \brief Marks all allocations in given pool as lost if they are not used in current frame or VmaPoolCreateInfo::frameInUseCount back from now.
    ///
    /// @param allocator Allocator object.
    /// @param pool Pool.
    /// @param[out] pLostAllocationCount Number of allocations marked as lost. Optional - pass null if you don't need this information.
    pub fn vmaMakePoolAllocationsLost(
        allocator: VmaAllocator,
        pool: VmaPool,
        pLostAllocationCount: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocation_T {
    _unused: [u8; 0],
}
pub type VmaAllocation = *mut VmaAllocation_T;
/// \brief Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().
#[repr(C)]
pub struct VmaAllocationInfo {
    /// \brief Memory type index that this allocation was allocated from.
    ///
    /// It never changes.
    pub memoryType: u32,
    /// \brief Handle to Vulkan memory object.
    ///
    /// Same memory object can be shared by multiple allocations.
    ///
    /// It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost.
    ///
    /// If the allocation is lost, it is equal to `VK_NULL_HANDLE`.
    pub deviceMemory: VkDeviceMemory,
    /// \brief Offset into deviceMemory object to the beginning of this allocation, in bytes. (deviceMemory, offset) pair is unique to this allocation.
    ///
    /// It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost.
    pub offset: VkDeviceSize,
    /// \brief Size of this allocation, in bytes.
    ///
    /// It never changes, unless allocation is lost.
    pub size: VkDeviceSize,
    /// \brief Pointer to the beginning of this allocation as mapped data.
    ///
    /// If the allocation hasn't been mapped using vmaMapMemory() and hasn't been
    /// created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value null.
    ///
    /// It can change after call to vmaMapMemory(), vmaUnmapMemory().
    /// It can also change after call to vmaDefragment() if this allocation is passed to the function.
    pub pMappedData: *mut ::std::os::raw::c_void,
    /// \brief Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vmaSetAllocationUserData().
    ///
    /// It can change after call to vmaSetAllocationUserData() for this allocation.
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VmaAllocationInfo() {
    assert_eq!(
        ::std::mem::size_of::<VmaAllocationInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VmaAllocationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaAllocationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaAllocationInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocationInfo>())).memoryType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(memoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocationInfo>())).deviceMemory as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(deviceMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocationInfo>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocationInfo>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocationInfo>())).pMappedData as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(pMappedData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VmaAllocationInfo>())).pUserData as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(pUserData)
        )
    );
}
extern "C" {
    /// \brief General purpose memory allocation.
    ///
    /// @param[out] pAllocation Handle to allocated memory.
    /// @param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().
    ///
    /// You should free the memory using vmaFreeMemory().
    ///
    /// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),
    /// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.
    pub fn vmaAllocateMemory(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const VkMemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    /// @param[out] pAllocation Handle to allocated memory.
    /// @param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().
    ///
    /// You should free the memory using vmaFreeMemory().
    pub fn vmaAllocateMemoryForBuffer(
        allocator: VmaAllocator,
        buffer: VkBuffer,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    /// Function similar to vmaAllocateMemoryForBuffer().
    pub fn vmaAllocateMemoryForImage(
        allocator: VmaAllocator,
        image: VkImage,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    /// Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage().
    pub fn vmaFreeMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
extern "C" {
    /// \brief Returns current information about specified allocation and atomically marks it as used in current frame.
    ///
    /// Current paramters of given allocation are returned in `pAllocationInfo`.
    ///
    /// This function also atomically "touches" allocation - marks it as used in current frame,
    /// just like vmaTouchAllocation().
    /// If the allocation is in lost state, `pAllocationInfo->deviceMemory == VK_NULL_HANDLE`.
    ///
    /// Although this function uses atomics and doesn't lock any mutex, so it should be quite efficient,
    /// you can avoid calling it too often.
    ///
    /// - You can retrieve same VmaAllocationInfo structure while creating your resource, from function
    /// vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change
    /// (e.g. due to defragmentation or allocation becoming lost).
    /// - If you just want to check if allocation is not lost, vmaTouchAllocation() will work faster.
    pub fn vmaGetAllocationInfo(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    );
}
extern "C" {
    /// \brief Returns `VK_TRUE` if allocation is not lost and atomically marks it as used in current frame.
    ///
    /// If the allocation has been created with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag,
    /// this function returns `VK_TRUE` if it's not in lost state, so it can still be used.
    /// It then also atomically "touches" the allocation - marks it as used in current frame,
    /// so that you can be sure it won't become lost in current frame or next `frameInUseCount` frames.
    ///
    /// If the allocation is in lost state, the function returns `VK_FALSE`.
    /// Memory of such allocation, as well as buffer or image bound to it, should not be used.
    /// Lost allocation and the buffer/image still need to be destroyed.
    ///
    /// If the allocation has been created without #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag,
    /// this function always returns `VK_TRUE`.
    pub fn vmaTouchAllocation(allocator: VmaAllocator, allocation: VmaAllocation) -> VkBool32;
}
extern "C" {
    /// \brief Sets pUserData in given allocation to new value.
    ///
    /// If the allocation was created with VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT,
    /// pUserData must be either null, or pointer to a null-terminated string. The function
    /// makes local copy of the string and sets it as allocation's `pUserData`. String
    /// passed as pUserData doesn't need to be valid for whole lifetime of the allocation -
    /// you can free it after this call. String previously pointed by allocation's
    /// pUserData is freed from memory.
    ///
    /// If the flag was not used, the value of pointer `pUserData` is just copied to
    /// allocation's `pUserData`. It is opaque, so you can use it however you want - e.g.
    /// as a pointer, ordinal number or some handle to you own data.
    pub fn vmaSetAllocationUserData(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// \brief Creates new allocation that is in lost state from the beginning.
    ///
    /// It can be useful if you need a dummy, non-null allocation.
    ///
    /// You still need to destroy created object using vmaFreeMemory().
    ///
    /// Returned allocation is not tied to any specific memory pool or memory type and
    /// not bound to any image or buffer. It has size = 0. It cannot be turned into
    /// a real, non-empty allocation.
    pub fn vmaCreateLostAllocation(allocator: VmaAllocator, pAllocation: *mut VmaAllocation);
}
extern "C" {
    /// \brief Maps memory represented by given allocation and returns pointer to it.
    ///
    /// Maps memory represented by given allocation to make it accessible to CPU code.
    /// When succeeded, `*ppData` contains pointer to first byte of this memory.
    /// If the allocation is part of bigger `VkDeviceMemory` block, the pointer is
    /// correctly offseted to the beginning of region assigned to this particular
    /// allocation.
    ///
    /// Mapping is internally reference-counted and synchronized, so despite raw Vulkan
    /// function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`
    /// multiple times simultaneously, it is safe to call this function on allocations
    /// assigned to the same memory block. Actual Vulkan memory will be mapped on first
    /// mapping and unmapped on last unmapping.
    ///
    /// If the function succeeded, you must call vmaUnmapMemory() to unmap the
    /// allocation when mapping is no longer needed or before freeing the allocation, at
    /// the latest.
    ///
    /// It also safe to call this function multiple times on the same allocation. You
    /// must call vmaUnmapMemory() same number of times as you called vmaMapMemory().
    ///
    /// It is also safe to call this function on allocation created with
    /// #VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.
    /// You must still call vmaUnmapMemory() same number of times as you called
    /// vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the
    /// "0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.
    ///
    /// This function fails when used on allocation made in memory type that is not
    /// `HOST_VISIBLE`.
    ///
    /// This function always fails when called for allocation that was created with
    /// #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocations cannot be
    /// mapped.
    pub fn vmaMapMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    /// \brief Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().
    ///
    /// For details, see description of vmaMapMemory().
    pub fn vmaUnmapMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
/// \brief Optional configuration parameters to be passed to function vmaDefragment().
#[repr(C)]
pub struct VmaDefragmentationInfo {
    /// \brief Maximum total numbers of bytes that can be copied while moving allocations to different places.
    ///
    /// Default is `VK_WHOLE_SIZE`, which means no limit.
    pub maxBytesToMove: VkDeviceSize,
    /// \brief Maximum number of allocations that can be moved to different place.
    ///
    /// Default is `UINT32_MAX`, which means no limit.
    pub maxAllocationsToMove: u32,
}
#[test]
fn bindgen_test_layout_VmaDefragmentationInfo() {
    assert_eq!(
        ::std::mem::size_of::<VmaDefragmentationInfo>(),
        16usize,
        concat!("Size of: ", stringify!(VmaDefragmentationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaDefragmentationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaDefragmentationInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaDefragmentationInfo>())).maxBytesToMove as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationInfo),
            "::",
            stringify!(maxBytesToMove)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaDefragmentationInfo>())).maxAllocationsToMove as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationInfo),
            "::",
            stringify!(maxAllocationsToMove)
        )
    );
}
/// \brief Statistics returned by function vmaDefragment().
#[repr(C)]
pub struct VmaDefragmentationStats {
    /// Total number of bytes that have been copied while moving allocations to different places.
    pub bytesMoved: VkDeviceSize,
    /// Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects.
    pub bytesFreed: VkDeviceSize,
    /// Number of allocations that have been moved to different places.
    pub allocationsMoved: u32,
    /// Number of empty `VkDeviceMemory` objects that have been released to the system.
    pub deviceMemoryBlocksFreed: u32,
}
#[test]
fn bindgen_test_layout_VmaDefragmentationStats() {
    assert_eq!(
        ::std::mem::size_of::<VmaDefragmentationStats>(),
        24usize,
        concat!("Size of: ", stringify!(VmaDefragmentationStats))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaDefragmentationStats>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaDefragmentationStats))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaDefragmentationStats>())).bytesMoved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationStats),
            "::",
            stringify!(bytesMoved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaDefragmentationStats>())).bytesFreed as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationStats),
            "::",
            stringify!(bytesFreed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaDefragmentationStats>())).allocationsMoved as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationStats),
            "::",
            stringify!(allocationsMoved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VmaDefragmentationStats>())).deviceMemoryBlocksFreed as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationStats),
            "::",
            stringify!(deviceMemoryBlocksFreed)
        )
    );
}
extern "C" {
    /// \brief Compacts memory by moving allocations.
    ///
    /// @param pAllocations Array of allocations that can be moved during this compation.
    /// @param allocationCount Number of elements in pAllocations and pAllocationsChanged arrays.
    /// @param[out] pAllocationsChanged Array of boolean values that will indicate whether matching allocation in pAllocations array has been moved. This parameter is optional. Pass null if you don't need this information.
    /// @param pDefragmentationInfo Configuration parameters. Optional - pass null to use default values.
    /// @param[out] pDefragmentationStats Statistics returned by the function. Optional - pass null if you don't need this information.
    /// @return VK_SUCCESS if completed, VK_INCOMPLETE if succeeded but didn't make all possible optimizations because limits specified in pDefragmentationInfo have been reached, negative error code in case of error.
    ///
    /// This function works by moving allocations to different places (different
    /// `VkDeviceMemory` objects and/or different offsets) in order to optimize memory
    /// usage. Only allocations that are in pAllocations array can be moved. All other
    /// allocations are considered nonmovable in this call. Basic rules:
    ///
    /// - Only allocations made in memory types that have
    /// `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag can be compacted. You may pass other
    /// allocations but it makes no sense - these will never be moved.
    /// - You may pass allocations made with #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT but
    /// it makes no sense - they will never be moved.
    /// - Both allocations made with or without #VMA_ALLOCATION_CREATE_MAPPED_BIT
    /// flag can be compacted. If not persistently mapped, memory will be mapped
    /// temporarily inside this function if needed.
    /// - You must not pass same #VmaAllocation object multiple times in pAllocations array.
    ///
    /// The function also frees empty `VkDeviceMemory` blocks.
    ///
    /// After allocation has been moved, its VmaAllocationInfo::deviceMemory and/or
    /// VmaAllocationInfo::offset changes. You must query them again using
    /// vmaGetAllocationInfo() if you need them.
    ///
    /// If an allocation has been moved, data in memory is copied to new place
    /// automatically, but if it was bound to a buffer or an image, you must destroy
    /// that object yourself, create new one and bind it to the new memory pointed by
    /// the allocation. You must use `vkDestroyBuffer()`, `vkDestroyImage()`,
    /// `vkCreateBuffer()`, `vkCreateImage()` for that purpose and NOT vmaDestroyBuffer(),
    /// vmaDestroyImage(), vmaCreateBuffer(), vmaCreateImage()! Example:
    ///
    /// \code
    /// VkDevice device = ...;
    /// VmaAllocator allocator = ...;
    /// std::vector<VkBuffer> buffers = ...;
    /// std::vector<VmaAllocation> allocations = ...;
    ///
    /// std::vector<VkBool32> allocationsChanged(allocations.size());
    /// vmaDefragment(allocator, allocations.data(), allocations.size(), allocationsChanged.data(), nullptr, nullptr);
    ///
    /// for(size_t i = 0; i < allocations.size(); ++i)
    /// {
    /// if(allocationsChanged[i])
    /// {
    /// VmaAllocationInfo allocInfo;
    /// vmaGetAllocationInfo(allocator, allocations[i], &allocInfo);
    ///
    /// vkDestroyBuffer(device, buffers[i], nullptr);
    ///
    /// VkBufferCreateInfo bufferInfo = ...;
    /// vkCreateBuffer(device, &bufferInfo, nullptr, &buffers[i]);
    ///
    /// // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.
    ///
    /// vkBindBufferMemory(device, buffers[i], allocInfo.deviceMemory, allocInfo.offset);
    /// }
    /// }
    /// \endcode
    ///
    /// Note: Please don't expect memory to be fully compacted after this call.
    /// Algorithms inside are based on some heuristics that try to maximize number of Vulkan
    /// memory blocks to make totally empty to release them, as well as to maximimze continuous
    /// empty space inside remaining blocks, while minimizing the number and size of data that
    /// needs to be moved. Some fragmentation still remains after this call. This is normal.
    ///
    /// Warning: This function is not 100% correct according to Vulkan specification. Use it
    /// at your own risk. That's because Vulkan doesn't guarantee that memory
    /// requirements (size and alignment) for a new buffer or image are consistent. They
    /// may be different even for subsequent calls with the same parameters. It really
    /// does happen on some platforms, especially with images.
    ///
    /// Warning: This function may be time-consuming, so you shouldn't call it too often
    /// (like every frame or after every resource creation/destruction).
    /// You can call it on special occasions (like when reloading a game level or
    /// when you just destroyed a lot of objects).
    pub fn vmaDefragment(
        allocator: VmaAllocator,
        pAllocations: *mut VmaAllocation,
        allocationCount: usize,
        pAllocationsChanged: *mut VkBool32,
        pDefragmentationInfo: *const VmaDefragmentationInfo,
        pDefragmentationStats: *mut VmaDefragmentationStats,
    ) -> VkResult;
}
extern "C" {
    /// \brief Binds buffer to allocation.
    ///
    /// Binds specified buffer to region of memory represented by specified allocation.
    /// Gets `VkDeviceMemory` handle and offset from the allocation.
    /// If you want to create a buffer, allocate memory for it and bind them together separately,
    /// you should use this function for binding instead of standard `vkBindBufferMemory()`,
    /// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple
    /// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously
    /// (which is illegal in Vulkan).
    ///
    /// It is recommended to use function vmaCreateBuffer() instead of this one.
    pub fn vmaBindBufferMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        buffer: VkBuffer,
    ) -> VkResult;
}
extern "C" {
    /// \brief Binds image to allocation.
    ///
    /// Binds specified image to region of memory represented by specified allocation.
    /// Gets `VkDeviceMemory` handle and offset from the allocation.
    /// If you want to create an image, allocate memory for it and bind them together separately,
    /// you should use this function for binding instead of standard `vkBindImageMemory()`,
    /// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple
    /// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously
    /// (which is illegal in Vulkan).
    ///
    /// It is recommended to use function vmaCreateImage() instead of this one.
    pub fn vmaBindImageMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        image: VkImage,
    ) -> VkResult;
}
extern "C" {
    /// @param[out] pBuffer Buffer that was created.
    /// @param[out] pAllocation Allocation that was created.
    /// @param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().
    ///
    /// This function automatically:
    ///
    /// -# Creates buffer.
    /// -# Allocates appropriate memory for it.
    /// -# Binds the buffer with the memory.
    ///
    /// If any of these operations fail, buffer and allocation are not created,
    /// returned value is negative error code, *pBuffer and *pAllocation are null.
    ///
    /// If the function succeeded, you must destroy both buffer and allocation when you
    /// no longer need them using either convenience function vmaDestroyBuffer() or
    /// separately, using `vkDestroyBuffer()` and vmaFreeMemory().
    ///
    /// If VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,
    /// VK_KHR_dedicated_allocation extension is used internally to query driver whether
    /// it requires or prefers the new buffer to have dedicated allocation. If yes,
    /// and if dedicated allocation is possible (VmaAllocationCreateInfo::pool is null
    /// and VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated
    /// allocation for this buffer, just like when using
    /// VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
    pub fn vmaCreateBuffer(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pBuffer: *mut VkBuffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    /// \brief Destroys Vulkan buffer and frees allocated memory.
    ///
    /// This is just a convenience function equivalent to:
    ///
    /// \code
    /// vkDestroyBuffer(device, buffer, allocationCallbacks);
    /// vmaFreeMemory(allocator, allocation);
    /// \endcode
    ///
    /// It it safe to pass null as buffer and/or allocation.
    pub fn vmaDestroyBuffer(allocator: VmaAllocator, buffer: VkBuffer, allocation: VmaAllocation);
}
extern "C" {
    /// Function similar to vmaCreateBuffer().
    pub fn vmaCreateImage(
        allocator: VmaAllocator,
        pImageCreateInfo: *const VkImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pImage: *mut VkImage,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    /// \brief Destroys Vulkan image and frees allocated memory.
    ///
    /// This is just a convenience function equivalent to:
    ///
    /// \code
    /// vkDestroyImage(device, image, allocationCallbacks);
    /// vmaFreeMemory(allocator, allocation);
    /// \endcode
    ///
    /// It it safe to pass null as image and/or allocation.
    pub fn vmaDestroyImage(allocator: VmaAllocator, image: VkImage, allocation: VmaAllocation);
}
